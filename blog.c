Title: Demystifying Shell Execution: Behind the Scenes of ls -l *.c

Introduction
    The command ls -l *.c serves a crucial role in the world of shell commands. By listing files with detailed information and filtering by a wildcard pattern, it allows users to quickly access specific files of interest. In this blog post, well dive into the intricate journey this seemingly simple command takes within a shell environment. Join us as we dissect each step to understand the mechanics and cooperation between the shell, system calls, and the ultimate command execution.

The Command Breakdown
    Breaking down the command, we have:

Explain the components of the command:

    ls: The command to list files and directories.
    -l: The option to display detailed information.
    *.c: The wildcard pattern to match all files with the .c extension.

Step-by-Step Execution

    User Input:
        The journey begins as you type the command ["ls", "-l", "*.c"] into the shell prompt.

    Tokenization:
        The shell ["tokenizes"] your input into separate arguments, creating an ["array"] of strings: ["ls", "-l", "*.c"].

    Searching for the Command:
        The shell searches for the executable file ["ls"] in directories listed in the ["PATH"] environment variable.

    Creating Child Process:
        A child process is created using the ["fork"] system call. This process is a duplicate of the parent process (the shell).

    Replacing Child Process Code:
        The child processes code is replaced with the code of the ["ls"] command using the ["exec"] system call.

    System Call: exec:
        The ["exec"] system call loads the executable code of the ["ls"] command into the child processes memory space.

    Command Execution:
        The ["ls"] command is executed within the child processes, interacting with the systems file structures.

    Output Display:
        The output generated by the ["ls", "-l"] command is displayed in the terminal, listing the [*.c] files along with detailed information.

Conclusion
    In this voyage through the execution of ["ls", "-l", "*.c"] we have witnessed a harmonious symphony between the shell and system calls. 
    From the initial tokenization of input to the creation of child processes and the eventual execution of the desired command.
    Each element dances in coordination, offering you the expected output. 
    This intricate choreography amalgamates software and system resources, culminating in a seamless user experience.
    The shell is a powerful tool, and the system calls are the tools of the shell.

Share and Connect

    Mention that the blog post was authored by your project team.
    Sweety Marie Castro Melendez | Hector Rodriguez Lopez